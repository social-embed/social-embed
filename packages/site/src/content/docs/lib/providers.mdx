---
id: providers
title: Matchers
description: URL matchers and custom provider support
sidebar:
  order: 20
---

A **Matcher** is an object that tells the library how to detect and embed a specific media service (e.g., YouTube, Vimeo, Spotify, or your own custom platform). Each Matcher has a consistent interface with methods to:

1. **Check** if a URL can be matched (`canMatch(ctx)`).
2. **Parse** the URL into structured data (`parse(ctx)`).
3. **Generate** an embed URL from parsed data (`toEmbedUrl(data)`).
4. **Generate** structured output for rendering (`toOutput(data)`).

## What Is a Matcher?

In code terms, each matcher implements the `UrlMatcher` interface:

```ts
import type { MatchContext, Result, EmbedOutput } from "@social-embed/lib";

/**
 * URL Matcher interface with generic type parameters.
 */
export interface UrlMatcher<
  TName extends string = string,
  TData = unknown,
  TOptions = object
> {
  /** Unique name for the matcher (e.g., "YouTube") */
  readonly name: TName;

  /** Domains this matcher handles (for O(1) indexed dispatch) */
  readonly domains?: readonly string[];

  /** Whether this matcher supports privacy-enhanced mode */
  readonly supportsPrivacyMode?: boolean;

  /** Quick check if this matcher can handle the URL */
  canMatch(ctx: MatchContext): boolean;

  /** Parse URL into structured data */
  parse(ctx: MatchContext): Result<TData>;

  /** Generate embed URL from parsed data */
  toEmbedUrl(data: TData, options?: PrivacyOptions & TOptions): string;

  /** Generate structured output for rendering */
  toOutput(data: TData, options?: OutputOptions & TOptions): EmbedOutput;
}
```

- **`name`**: A unique string label (e.g. `"YouTube"`, `"Spotify"`, `"MyCustom"`)
- **`domains`**: List of domains for O(1) lookup (e.g. `["youtube.com", "youtu.be"]`)
- **`canMatch(ctx)`**: Quick check using pre-parsed URL context
- **`parse(ctx)`**: Extracts structured data from the URL, returns `Result<TData>`
- **`toEmbedUrl(data)`**: Builds the iframe-friendly embed URL
- **`toOutput(data)`**: Returns structured `EmbedOutput` with nodes, scripts, styles

## Built-in Matchers

@social-embed/lib ships with built-in matchers for:
- **YouTube** - Standard, short, and embed URLs
- **Vimeo** - Video URLs with player embed
- **Spotify** - Tracks, albums, playlists, artists, shows, episodes
- **DailyMotion** - Standard and short URLs
- **Loom** - Share URLs
- **Wistia** - Media and embed URLs
- **EdPuzzle** - Media URLs

All built-in matchers support privacy-enhanced mode where applicable.

## Using the Registry

The recommended way to use matchers is through `MatcherRegistry`:

```ts
import { MatcherRegistry } from "@social-embed/lib";

// Create registry with all built-in matchers
const registry = MatcherRegistry.withDefaults();

// Match a URL
const result = registry.match("https://youtu.be/dQw4w9WgXcQ");

if (result.ok) {
  console.log(result.matcher.name);  // "YouTube"
  console.log(result.data);          // { id: "dQw4w9WgXcQ" }

  // Get embed URL (privacy-enhanced by default)
  const embedUrl = result.matcher.toEmbedUrl(result.data);
  // => "https://www.youtube-nocookie.com/embed/dQw4w9WgXcQ"

  // Get structured output
  const output = result.matcher.toOutput(result.data, { width: 800 });
}
```

## Adding a Custom Matcher

If you want to support a media service that @social-embed/lib doesn't cover, you can create a custom matcher.

### Option 1: Using `defineIframeMatcher` (Recommended)

For simple iframe-based embeds, use the factory function:

```ts
import { defineIframeMatcher, MatcherRegistry } from "@social-embed/lib";

const TikTokMatcher = defineIframeMatcher({
  name: "TikTok",
  domains: ["tiktok.com"],
  patterns: [/tiktok\.com\/@[\w]+\/video\/(\d+)/],
  embedUrl: (id) => `https://www.tiktok.com/embed/${id}`,
  defaultDimensions: { width: 325, height: 580 },
});

// Add to registry
const registry = MatcherRegistry.withDefaults().with(TikTokMatcher);

// Or create a fresh registry
const customRegistry = MatcherRegistry.create([TikTokMatcher]);
```

### Option 2: Implementing UrlMatcher Directly

For complex matchers (like Spotify with multiple content types):

```ts
import type { UrlMatcher, MatchContext, Result, EmbedOutput } from "@social-embed/lib";
import { ok, noMatch, hostMatches } from "@social-embed/lib";

interface MyServiceData {
  id: string;
  type: "video" | "audio";
}

const MyServiceMatcher: UrlMatcher<"MyService", MyServiceData> = {
  name: "MyService",
  domains: ["myservice.example.com"],

  canMatch(ctx: MatchContext): boolean {
    return hostMatches(ctx, ["myservice.example.com"]);
  },

  parse(ctx: MatchContext): Result<MyServiceData> {
    const videoMatch = ctx.raw.match(/myservice\.example\.com\/video\/(\w+)/);
    if (videoMatch) {
      return ok({ id: videoMatch[1], type: "video" });
    }

    const audioMatch = ctx.raw.match(/myservice\.example\.com\/audio\/(\w+)/);
    if (audioMatch) {
      return ok({ id: audioMatch[1], type: "audio" });
    }

    return noMatch("No pattern matched");
  },

  toEmbedUrl(data: MyServiceData): string {
    return `https://myservice.example.com/embed/${data.type}/${data.id}`;
  },

  toOutput(data: MyServiceData, options): EmbedOutput {
    return {
      nodes: [{
        type: "iframe",
        src: this.toEmbedUrl(data, options),
        attributes: {
          width: String(options?.width ?? 640),
          height: String(options?.height ?? 360),
        },
      }],
    };
  },
};
```

### Registering Custom Matchers

```ts
import { MatcherRegistry } from "@social-embed/lib";

// Add to default registry (mutable)
const registry = MatcherRegistry.withDefaults();
registry.register(MyServiceMatcher);

// Or create new registry with custom matcher (immutable)
const extended = registry.with(MyServiceMatcher);

// Or start fresh with only your matchers
const custom = MatcherRegistry.create([MyServiceMatcher]);
```

## Result Type and Error Handling

All parse operations return a `Result<T>` type for explicit error handling:

```ts
const result = registry.match("https://invalid-url.com");

if (result.ok) {
  // Success - access result.matcher and result.data
  console.log(result.data);
} else {
  // Error - access result.error
  console.log(result.error.code);     // "NO_MATCH" | "INVALID_FORMAT" | etc.
  console.log(result.error.message);  // Human-readable message
  console.log(result.error.fatal);    // Should other matchers try?
}
```

## Privacy-Enhanced Mode

Privacy mode is enabled by default for supported matchers:

```ts
// Privacy enabled (default)
registry.toEmbedUrl("https://youtu.be/abc123");
// => "https://www.youtube-nocookie.com/embed/abc123"

// Privacy disabled
registry.toEmbedUrl("https://youtu.be/abc123", { privacy: false });
// => "https://www.youtube.com/embed/abc123"
```

## Further Reading

- [Examples](/lib/examples): Real code samples for built-in matchers
- [Migration Guide](/lib/migration): Migrating from v1 API
- [@social-embed/wc](https://social-embed.org/wc/): Web component using these matchers

---

**In short:** A **Matcher** is a plugin that knows how to detect a service's URLs and generate embed-friendly output. Use built-in matchers for mainstream services, or create your own with `defineIframeMatcher()` or by implementing `UrlMatcher` directly.
